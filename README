PyAspects is a project to ease aspect-oriented programming in Python language.

### Basic Usage ###

"weave" convenience function can use ordinary functions to apply
aspects to a class, object or a method.

- When used with a class, all methods of the class will be
  weaved. This will affect all instances of the class.

- When used with an object, all methods of the object will be
  weaved. But this won't affect any other instances of the same
  class.

- When used with a method, only that particular method will be
  weaved.

Example:
Using the convenience function w/o creating an aspect.


def my_before_func(wobj, data, *args, **kwargs):
    # wobj: the object that is wrapped
    # data: aspect's data where you can get the original method name
    # args: arguments passed to the original method
    # kwargs: keywords passed to the original method
    do_something()

pyaspects.weave(some_object_class_or_method, before_func=my_before_func)


Using an aspect to weave a method, class, object.

pyaspects.weave_all_methods(MyAspect(), MyClass)
pyaspects.weave_all_methods(MyAspect(), MyClass.my_method)
pyaspects.weave_all_methods(MyAspect(), my_instance)
pyaspects.weave_all_methods(MyAspect(), my_instance.my_method)

### How to define a new aspect ###

Aspects can provide methods to be executed before or after the weaved
methods.

Example:
The example TestAspect below will print a line after executing the
original method.

class TestAspect:
    __metaclass__ = MetaAspect
    name = "TestAspect"

    def after(self, wobj, data, *args, **kwargs):
        print "Test aspect"
