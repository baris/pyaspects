{"name":"Pyaspects","body":"PyAspects is a project to ease aspect-oriented programming in Python language.\r\n\r\n### Basic Usage ###\r\n\r\n\"weave\" convenience function can use ordinary functions to apply\r\naspects to a class, object or a method.\r\n\r\n- When used with a class, all methods of the class will be\r\n  weaved. This will affect all instances of the class.\r\n\r\n- When used with an object, all methods of the object will be\r\n  weaved. But this won't affect any other instances of the same\r\n  class.\r\n\r\n- When used with a method, only that particular method will be\r\n  weaved.\r\n\r\nExample:\r\nUsing the convenience function w/o creating an aspect.\r\n\r\n```\r\ndef my_before_func(wobj, data, *args, **kwargs):\r\n    # wobj: the object that is wrapped\r\n    # data: aspect's data where you can get information about the weaved method\r\n    # args: arguments passed to the original method\r\n    # kwargs: keywords passed to the original method\r\n    do_something()\r\n\r\npyaspects.weave(some_object_class_or_method, before_func=my_before_func)\r\n```\r\n\r\nUsing an aspect to weave a method, class, object.\r\n\r\n```\r\npyaspects.weave_all_methods(MyAspect(), MyClass)\r\npyaspects.weave_all_methods(MyAspect(), MyClass.my_method)\r\npyaspects.weave_all_methods(MyAspect(), my_instance)\r\npyaspects.weave_all_methods(MyAspect(), my_instance.my_method)\r\n```\r\n\r\n### Types of Advices ###\r\n\r\nWith pyaspects you can inject some code before, after or instead\r\n(around) of a method.\r\n\r\nbefore and after advices are quite strait-forward they basically get\r\nthe object and arguments of the method and run before/after the\r\nexecution of the method. You can have as many before/after advices as\r\nyou want to.\r\n\r\nOn the other hand, a method can only have one around advise. This is\r\nbecause around advice will be run in place and it's return value will\r\nbe used instead. But, around advice can invoke the original method\r\nusing the proceed method of the MetaAspect.\r\n\r\n\r\n### What is in \"data\" ###\r\n\r\nThe data argument passed to aspects is a dictionary and provides\r\ninformation about the weaved method.\r\n\r\ndata['original_method_name'] : The method name before weaving happens.\r\n\r\ndata['method_name'] : Weaved method name. This is basically the method\r\n\"proceed\" will call in around aspect.\r\n\r\ndata['method_return_value'] : Return value of the original\r\nmethod. This will be available only to after aspect and around aspect\r\n(if it calls proceed).\r\n\r\ndata['__class__'] : Class object that the method belongs to.\r\n\r\n### How to define a new aspect ###\r\n\r\nAspects can provide methods to be executed before or after the weaved\r\nmethods.\r\n\r\nExample: \r\n\r\n```\r\nclass TestAspect:\r\n    __metaclass__ = MetaAspect\r\n    name = \"TestAspect\"\r\n\r\n    def after(self, wobj, data, *args, **kwargs):\r\n        print \"Test aspect\"\r\n\r\n\r\nclass MyAroundAspect:\r\n    __metaclass__ = MetaAspect\r\n    name = \"MyAround\"\r\n\r\n    def around(self, wobj, data, *args, **kwargs):\r\n        print \"running around.\"\r\n        ret = self.proceed(wobj, data, *args, **kwargs)\r\n        print \"do something with return value\"\r\n        return ret\r\n```\r\n","tagline":"aspect oriented programming library for Python","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}